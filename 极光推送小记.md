# 极光推送小记

## 通知栏点击跳转页面
  使用deeplink 方式
  需要在AndroidManifest.xml 中<activity>添加 deeplink 
              <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data
                    android:scheme="scheme"
                    android:host="host"
                    android:path="/path"/>
            </intent-filter>
  需要将设置android:launchMode="singleTask"为栈内复用才不会多开一个进程
  <meta-data android:name="flutter_deeplinking_enabled" android:value="false" /> 关闭flutter对deeplink原生支持

            
            
## 小米厂商需要配置 channelId, 不然收不到推送消息
## 推送的文本字数每个厂商渠道都不一致，超过则推送失败 ：https://docs.jiguang.cn/jpush/server/push/rest_api_v3_push#%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83

## iOS设置通知图片：https://go48pg.yuque.com/go48pg/pa41sm/ql7sveloytztoegx?singleDoc#pA0TL
1. Runner -> Signing&Capabilities -> Capabitity 搜索添加 Communication Notifications<img width="855" height="688" alt="image" src="https://github.com/user-attachments/assets/5bc09043-a5bd-4abe-85a4-90b4d4da7af5" />
2. File -> New -> Target -> Notification Service Extension <img width="723" height="509" alt="image" src="https://github.com/user-attachments/assets/461225be-3f66-46fa-98f7-503d342731b9" />
填写ProductName <img width="716" height="505" alt="image" src="https://github.com/user-attachments/assets/e858b7f3-7d72-45c1-89bc-9cbbe03d9f13" />

3. 如果运行出现了 Cycle insideRunner; building could produce unreliable results.
Cycle details:
→ Target 'Runner': ExtractAppIntentsMetadata
需要在 Runner -> Build Phases 调整编译顺序将Embed Foundation Extensions 放到 Run Script前面 <img width="619" height="548" alt="image" src="https://github.com/user-attachments/assets/76fc625f-ee33-40e0-9224-2b73a88b9803" />

4. 直接将 jpush-extension-ios.xcframework 直接拖拽进创建的 Notification Service Extension 项目中引入
5. ```
    /// 设置通知栏图片
   #import "NotificationService.h"
    #import "JPushNotificationExtensionService.h"
    #import <Intents/Intents.h>

    @interface NotificationService ()

    @property(nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);
    @property(nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;

    @end

    @implementation NotificationService

    - (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(
        UNNotificationContent *_Nonnull))contentHandler {
    self.contentHandler = contentHandler;
    self.bestAttemptContent = [request.content mutableCopy];
    self.bestAttemptContent.title = self.bestAttemptContent.title;
    // 对应通知的自定义图片参数
    NSString *attachmentPath = self.bestAttemptContent.userInfo[@"big_pic_path"];
    //if exist
    if (attachmentPath) {
        //download
        NSURL *fileURL = [NSURL URLWithString:attachmentPath];
        [self downloadAndSave:fileURL handler:^(NSString *localPath) {
            if (localPath) {
                UNNotificationAttachment *attachment = [UNNotificationAttachment attachmentWithIdentifier:@"myAttachment" URL:[NSURL fileURLWithPath:localPath] options:nil error:nil];
                self.bestAttemptContent.attachments = @[attachment];
            }
            [self apnsDeliverWith:request];
        }];
    } else {
        [self apnsDeliverWith:request];
    }
    }

    - (void)downloadAndSave:(NSURL *)fileURL handler:(void (^)(NSString *))handler {
    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionDownloadTask *task = [session downloadTaskWithURL:fileURL completionHandler:^(
            NSURL *_Nullable location, NSURLResponse *_Nullable response, NSError *_Nullable
            error) {
        NSString *localPath = nil;
        if (!error) {
            NSString *localURL = [NSString stringWithFormat:@"%@/%@", NSTemporaryDirectory(), fileURL.lastPathComponent];
            if ([[NSFileManager defaultManager] moveItemAtPath:location.path toPath:localURL error:nil]) { localPath = localURL; }
        }
        handler(localPath);
    }];
    [task resume];
    }

    - (void)apnsDeliverWith:(UNNotificationRequest *)request {

    //please invoke this func on release version
    [JPushNotificationExtensionService setLogOff];

    //service extension sdk
    //upload to calculate delivery rate
    //    [JPushNotificationExtensionService jpushSetAppkey:@"AppKey copied from JiGuang Portal application"];
    //    [JPushNotificationExtensionService jpushReceiveNotificationRequest:request with:^ {
    //        NSLog(@"apns upload success");
    //        self.contentHandler(self.bestAttemptContent);
    //    }];
    self.contentHandler(self.bestAttemptContent);
    }

    - (void)serviceExtensionTimeWillExpire {
    self.contentHandler(self.bestAttemptContent);
    }

    @end
```
7. 如果在 Notification Service Extension 项目进程中打印日志，Xcode 控制台无法查看，需要在 Xcode -> Window -> Devices And Simulators 中选择对应的iOS设备 -> open console 中可以查看日志


